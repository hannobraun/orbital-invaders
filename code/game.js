// Generated by CoffeeScript 1.3.1
(function() {

  window.module = function(moduleName, dependencyNames, moduleFactory) {
    if (window.modules == null) {
      window.modules = {};
    }
    if (window.modules[moduleName] == null) {
      return window.modules[moduleName] = {
        name: moduleName,
        dependencyNames: dependencyNames,
        factory: moduleFactory
      };
    } else {
      throw "Module " + moduleName + " is already defined.";
    }
  };

  window.load = function(moduleName, loadedModules) {
    var dependencies, dependencyName, module;
    if (window.modules == null) {
      throw "No modules have been defined.";
    }
    if (window.modules[moduleName] == null) {
      throw "A module called " + moduleName + " does not exist.";
    }
    if (loadedModules == null) {
      loadedModules = {};
    }
    if (loadedModules[moduleName] == null) {
      module = window.modules[moduleName];
      dependencies = (function() {
        var _i, _len, _ref, _results;
        _ref = module.dependencyNames;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          dependencyName = _ref[_i];
          if (modules[dependencyName] == null) {
            throw ("A module called \"" + dependencyName + "\" (defined as a ") + ("dependency in \"" + moduleName + "\") does not exist.");
          }
          _results.push(load(dependencyName, loadedModules));
        }
        return _results;
      })();
      loadedModules[moduleName] = module.factory.apply(void 0, dependencies);
    }
    return loadedModules[moduleName];
  };

  module("Transform2d", [], function() {
    var module;
    return module = {
      identityMatrix: function() {
        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
      },
      translationMatrix: function(v) {
        return [[1, 0, v[0]], [0, 1, v[1]], [0, 0, 1]];
      },
      rotationMatrix: function(angle) {
        return [[Math.cos(angle), -Math.sin(angle), 0], [Math.sin(angle), Math.cos(angle), 0], [0, 0, 1]];
      },
      scalingMatrix: function(factor) {
        return [[factor, 0, 0], [0, factor, 0], [0, 0, 1]];
      }
    };
  });

  module("Entities", [], function() {
    var module;
    return module = {
      createEntity: function(factories, components, type, args) {
        var component, componentName, entity, factory, _ref, _results;
        factory = factories[type];
        if (factory == null) {
          throw "Entity type \"" + type + "\" is not known.";
        }
        entity = factory(args);
        _ref = entity.components;
        _results = [];
        for (componentName in _ref) {
          component = _ref[componentName];
          if (components[componentName] == null) {
            components[componentName] = {};
          }
          _results.push(components[componentName][entity.id] = component);
        }
        return _results;
      },
      destroyEntity: function(components, entityId) {
        var componentMap, componentType, _results;
        _results = [];
        for (componentType in components) {
          componentMap = components[componentType];
          _results.push(delete componentMap[entityId]);
        }
        return _results;
      }
    };
  });

  module("Images", [], function() {
    var module;
    return module = {
      loadImages: function(imagePaths, onLoad) {
        var image, imagePath, images, numberOfImagesToLoad, _i, _len, _results;
        images = {};
        numberOfImagesToLoad = imagePaths.length;
        _results = [];
        for (_i = 0, _len = imagePaths.length; _i < _len; _i++) {
          imagePath = imagePaths[_i];
          image = new Image;
          images[imagePath] = image;
          image.onload = function() {
            numberOfImagesToLoad -= 1;
            if (numberOfImagesToLoad === 0) {
              return onLoad(images);
            }
          };
          _results.push(image.src = imagePath);
        }
        return _results;
      },
      process: function(rawImages) {
        var imageId, images, rawImage;
        images = {};
        for (imageId in rawImages) {
          rawImage = rawImages[imageId];
          images[imageId] = {
            rawImage: rawImage,
            positionOffset: [-rawImage.width / 2, -rawImage.height / 2],
            orientationOffset: 0
          };
        }
        return images;
      }
    };
  });

  module("VelocityVerletIntegrator", ["Vec2"], function(Vec2) {
    var module;
    return module = {
      integrate: function(bodies, passedTimeInS) {
        var body, entityId, force, movementFromAcceleration, movementFromVelocity, newAcceleration, velocityChange, _i, _len, _ref, _results;
        _results = [];
        for (entityId in bodies) {
          body = bodies[entityId];
          newAcceleration = [0, 0];
          _ref = body.forces;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            force = _ref[_i];
            Vec2.scale(force, 1 / body.mass);
            Vec2.add(newAcceleration, force);
          }
          body.forces.length = 0;
          movementFromVelocity = Vec2.copy(body.velocity);
          Vec2.scale(movementFromVelocity, passedTimeInS);
          movementFromAcceleration = Vec2.copy(body.acceleration);
          Vec2.scale(movementFromAcceleration, 0.5);
          Vec2.scale(movementFromAcceleration, passedTimeInS * passedTimeInS);
          Vec2.add(body.position, movementFromVelocity);
          Vec2.add(body.position, movementFromAcceleration);
          velocityChange = Vec2.copy(body.acceleration);
          Vec2.add(velocityChange, newAcceleration);
          Vec2.scale(velocityChange, 0.5);
          Vec2.scale(velocityChange, passedTimeInS);
          Vec2.add(body.velocity, velocityChange);
          _results.push(body.acceleration = newAcceleration);
        }
        return _results;
      }
    };
  });

  module("EulerIntegrator", ["Vec2"], function(Vec2) {
    var module;
    return module = {
      integrate: function(bodies, passedTimeInS) {
        var body, entityId, force, newAcceleration, positionChange, velocityChange, _i, _len, _ref, _results;
        _results = [];
        for (entityId in bodies) {
          body = bodies[entityId];
          newAcceleration = [0, 0];
          _ref = body.forces;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            force = _ref[_i];
            Vec2.scale(force, 1 / body.mass);
            Vec2.add(newAcceleration, force);
          }
          body.forces.length = 0;
          body.acceleration = newAcceleration;
          velocityChange = Vec2.copy(body.acceleration);
          Vec2.scale(velocityChange, passedTimeInS);
          Vec2.add(body.velocity, velocityChange);
          positionChange = Vec2.copy(body.velocity);
          Vec2.scale(positionChange, passedTimeInS);
          _results.push(Vec2.add(body.position, positionChange));
        }
        return _results;
      }
    };
  });

  module("CollisionResponse", ["Vec2"], function(Vec2) {
    var module;
    return module = {
      handleContacts: function(contacts, bodies, parameters) {
        var b, bodyA, bodyB, contact, damping, force, k, negativeForce, relativeVelocity, spring, _i, _len, _results;
        k = parameters.k;
        b = parameters.b;
        _results = [];
        for (_i = 0, _len = contacts.length; _i < _len; _i++) {
          contact = contacts[_i];
          bodyA = bodies[contact.bodyIds[0]];
          bodyB = bodies[contact.bodyIds[1]];
          relativeVelocity = Vec2.copy(bodyA.velocity);
          Vec2.subtract(relativeVelocity, bodyB.velocity);
          spring = Vec2.copy(contact.normal);
          Vec2.scale(spring, -k * contact.depth);
          damping = Vec2.copy(contact.normal);
          Vec2.scale(damping, b * Vec2.dot(contact.normal, relativeVelocity));
          force = Vec2.copy(spring);
          Vec2.add(force, damping);
          Vec2.scale(force, 0.5);
          negativeForce = Vec2.copy(force);
          Vec2.scale(negativeForce, -1);
          bodyA.forces.push(force);
          _results.push(bodyB.forces.push(negativeForce));
        }
        return _results;
      }
    };
  });

  module("Physics", ["Vec2"], function(Vec2) {
    var module;
    return module = {
      parameters: {
        collisionResponse: {
          k: 10000,
          b: 0
        }
      },
      createBody: function() {
        var body;
        return body = {
          position: [0, 0],
          velocity: [0, 0],
          acceleration: [0, 0],
          orientation: 0,
          angularVelocity: 0,
          forces: [],
          mass: 1
        };
      },
      integrateOrientation: function(bodies, passedTimeInS) {
        var body, entityId, _results;
        _results = [];
        for (entityId in bodies) {
          body = bodies[entityId];
          _results.push(body.orientation += body.angularVelocity * passedTimeInS);
        }
        return _results;
      },
      update: function(bodies, passedTimeInS, integrate) {
        integrate(bodies, passedTimeInS);
        return module.integrateOrientation(bodies, passedTimeInS);
      }
    };
  });

  module("CollisionDetection", ["Vec2"], function(Vec2) {
    var module;
    return module = {
      createCircle: function(radius) {
        var shape;
        return shape = {
          type: "circle",
          radius: radius
        };
      },
      buildPairs: function(shapes) {
        var entityIdA, entityIdB, entityUsed, pairs, shapeA, shapeB;
        entityUsed = {};
        pairs = [];
        for (entityIdA in shapes) {
          shapeA = shapes[entityIdA];
          entityUsed[entityIdA] = true;
          for (entityIdB in shapes) {
            shapeB = shapes[entityIdB];
            if (!entityUsed[entityIdB]) {
              pairs.push([entityIdA, entityIdB]);
            }
          }
        }
        return pairs;
      },
      checkCollisions: function(potentialPairs, bodies, shapes) {
        var collision, contacts, d, distance, normal, pair, penetrationDepth, point, positionA, positionB, shapeA, shapeB, sumOfRadii, _i, _len;
        contacts = [];
        for (_i = 0, _len = potentialPairs.length; _i < _len; _i++) {
          pair = potentialPairs[_i];
          positionA = bodies[pair[0]].position;
          positionB = bodies[pair[1]].position;
          shapeA = shapes[0];
          shapeB = shapes[1];
          sumOfRadii = shapeA.radius + shapeB.radius;
          d = Vec2.copy(positionB);
          Vec2.subtract(d, positionA);
          distance = Vec2.length(d);
          collision = sumOfRadii >= distance;
          if (collision) {
            normal = Vec2.copy(d);
            Vec2.normalize(normal);
            penetrationDepth = sumOfRadii - distance;
            point = Vec2.copy(normal);
            Vec2.scale(point, shapeA.radius - penetrationDepth / 2);
            Vec2.add(point, positionA);
            contacts.push({
              bodyIds: pair,
              normal: normal,
              depth: penetrationDepth,
              point: point
            });
          }
        }
        return contacts;
      }
    };
  });

  module("Rendering", [], function() {
    var module;
    return module = {
      drawFunctions: {
        "image": function(renderable, context, image) {
          context.translate(renderable.position[0], renderable.position[1]);
          context.rotate(renderable.orientation + image.orientationOffset);
          context.translate(image.positionOffset[0], image.positionOffset[1]);
          return context.drawImage(image.rawImage, 0, 0);
        },
        "circle": function(renderable, context, shape) {
          context.translate(renderable.position[0], renderable.position[1]);
          context.rotate(renderable.orientation);
          context.translate(shape.offset[0], shape.offset[1]);
          context.beginPath();
          context.arc(0, 0, shape.circle.radius, 0, Math.PI * 2, true);
          return context.stroke();
        },
        "filledCircle": function(renderable, context, circle) {
          context.fillStyle = circle.color;
          context.beginPath();
          context.arc(renderable.position[0], renderable.position[1], circle.radius, 0, 2 * Math.PI, false);
          context.fill();
          return context.closePath();
        },
        "ellipse": function(renderable, context, ellipse) {
          context.strokeStyle = ellipse.color;
          context.translate(renderable.position[0], renderable.position[1]);
          context.rotate(renderable.orientation);
          context.scale(ellipse.semiMajorAxis / ellipse.semiMinorAxis, 1);
          context.beginPath();
          context.arc(0, 0, ellipse.semiMinorAxis, 0, 2 * Math.PI, false);
          context.stroke();
          return context.closePath();
        },
        "rectangle": function(renderable, context, rectangle) {
          context.fillStyle = rectangle.color || "rgb(255,255,255)";
          return context.fillRect(renderable.position[0], renderable.position[1], rectangle.size[0], rectangle.size[1]);
        },
        "rectangleOutline": function(renderable, context, rectangle) {
          context.lineWidth = rectangle.lineWidth || 1;
          context.strokeStyle = rectangle.color || "rgb(0,0,0)";
          return context.strokeRect(renderable.position[0], renderable.position[1], rectangle.size[0], rectangle.size[1]);
        },
        "line": function(renderable, context, line) {
          context.strokeStyle = line.color || "rgb(255,255,255)";
          context.beginPath();
          context.moveTo(line.start[0], line.start[1]);
          context.lineTo(line.end[0], line.end[1]);
          context.closePath();
          return context.stroke();
        },
        "text": function(renderable, context, text) {
          var xPos, yPos;
          context.fillStyle = text.textColor || "rgb(0,0,0)";
          if (text.font != null) {
            context.font = text.font;
          }
          if (text.bold != null) {
            context.font = "bold " + context.font;
          }
          xPos = text.centered[0] ? renderable.position[0] - context.measureText(text.string).width / 2 : renderable.position[0];
          yPos = text.centered[1] ? renderable.position[1] + text.size / 2 : renderable.position[1];
          return context.fillText(text.string, xPos, yPos);
        }
      },
      createDisplay: function() {
        var canvas, context, display;
        canvas = document.getElementById("canvas");
        context = canvas.getContext("2d");
        context.translate(canvas.width / 2, canvas.height / 2);
        return display = {
          canvas: canvas,
          context: context,
          size: [canvas.width, canvas.height]
        };
      },
      createRenderable: function(type) {
        var renderable;
        return renderable = {
          type: type,
          resourceId: null,
          resource: null,
          position: [0, 0],
          orientation: 0
        };
      },
      render: function(drawFunctions, display, renderData, renderables) {
        var context, drawRenderable, height, renderable, resource, type, width, _i, _len, _results;
        context = display.context;
        width = display.size[0];
        height = display.size[1];
        context.clearRect(-width / 2, -height / 2, width, height);
        _results = [];
        for (_i = 0, _len = renderables.length; _i < _len; _i++) {
          renderable = renderables[_i];
          context.save();
          type = renderable.type;
          resource = renderable.resource != null ? renderable.resource : renderData[type][renderable.resourceId];
          if (resource == null) {
            throw "Resource " + renderable.resourceId + " does not exist.";
          }
          drawRenderable = drawFunctions[type];
          drawRenderable(renderable, context, resource);
          _results.push(context.restore());
        }
        return _results;
      }
    };
  });

  module("Events", [], function() {
    var module, publishToSubscribersOfEvent, publishToSubscribersOfSubject;
    publishToSubscribersOfEvent = function(subscribersByTopic, topic, event) {
      if (subscribersByTopic != null) {
        publishToSubscribersOfSubject(subscribersByTopic[topic], event);
        return publishToSubscribersOfSubject(subscribersByTopic[module.anyTopic], event);
      }
    };
    publishToSubscribersOfSubject = function(subscribersOfTopic, event) {
      var subscriber, _i, _len, _results;
      if (subscribersOfTopic != null) {
        _results = [];
        for (_i = 0, _len = subscribersOfTopic.length; _i < _len; _i++) {
          subscriber = subscribersOfTopic[_i];
          _results.push(subscriber(event));
        }
        return _results;
      }
    };
    return module = {
      anyEvent: "any event",
      anyTopic: "any topic",
      createSubscribers: function() {
        return {};
      },
      subscribe: function(subscribers, eventType, topics, subscriber) {
        var subscribersByTopic, subscribersOfTopic, topic, _i, _len;
        if (!(topics instanceof Array)) {
          throw "You must specify an array of topics.";
        }
        subscribersByTopic = subscribers[eventType];
        if (subscribersByTopic == null) {
          subscribersByTopic = {};
        }
        for (_i = 0, _len = topics.length; _i < _len; _i++) {
          topic = topics[_i];
          subscribersOfTopic = subscribersByTopic[topic];
          if (subscribersOfTopic == null) {
            subscribersOfTopic = [];
          }
          subscribersOfTopic.push(subscriber);
          subscribersByTopic[topic] = subscribersOfTopic;
        }
        return subscribers[eventType] = subscribersByTopic;
      },
      publish: function(subscribers, eventType, topic, event) {
        publishToSubscribersOfEvent(subscribers[eventType], topic, event);
        return publishToSubscribersOfEvent(subscribers[module.anyEvent], topic, event);
      }
    };
  });

  module("MainLoop", [], function() {
    var defaultCallNextFrame, maxPassedTimeInMs, module;
    maxPassedTimeInMs = 1000 / 30;
    defaultCallNextFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(f) {
      return window.setTimeout(function() {
        return f(Date.now());
      }, 1000 / 60);
    };
    return module = {
      execute: function(f, callNextFrame) {
        var mainLoop, previousTimeInMs;
        callNextFrame = callNextFrame || defaultCallNextFrame;
        previousTimeInMs = null;
        mainLoop = function(currentTimeInMs) {
          var currentTimeInS, passedTimeInMs, passedTimeInS;
          passedTimeInMs = currentTimeInMs - previousTimeInMs;
          previousTimeInMs = currentTimeInMs;
          passedTimeInMs = Math.min(passedTimeInMs, maxPassedTimeInMs);
          currentTimeInS = currentTimeInMs / 1000;
          passedTimeInS = passedTimeInMs / 1000;
          f(currentTimeInS, passedTimeInS);
          return callNextFrame(mainLoop);
        };
        return callNextFrame(mainLoop);
      }
    };
  });

  module("Input", [], function() {
    var ensureKeyNameIsValid, keyCode, keyCodesByName, keyName, keyNameArrayToKeyCodeSet, keyNamesByCode, module, mouseKeyCodesByName, mouseKeyNamesByCode, updatePointerPosition;
    keyNamesByCode = {
      8: "backspace",
      9: "tab",
      13: "enter",
      16: "shift",
      17: "ctrl",
      18: "alt",
      19: "pause",
      20: "caps lock",
      27: "escape",
      32: "space",
      33: "page up",
      34: "page down",
      35: "end",
      36: "home",
      37: "left arrow",
      38: "up arrow",
      39: "right arrow",
      40: "down arrow",
      45: "insert",
      46: "delete",
      48: "0",
      49: "1",
      50: "2",
      51: "3",
      52: "4",
      53: "5",
      54: "6",
      55: "7",
      56: "8",
      57: "9",
      65: "a",
      66: "b",
      67: "c",
      68: "d",
      69: "e",
      70: "f",
      71: "g",
      72: "h",
      73: "i",
      74: "j",
      75: "k",
      76: "l",
      77: "m",
      78: "n",
      79: "o",
      80: "p",
      81: "q",
      82: "r",
      83: "s",
      84: "t",
      85: "u",
      86: "v",
      87: "w",
      88: "x",
      89: "y",
      90: "z",
      91: "left window key",
      92: "right window key",
      93: "select key",
      96: "numpad 0",
      97: "numpad 1",
      98: "numpad 2",
      99: "numpad 3",
      100: "numpad 4",
      101: "numpad 5",
      102: "numpad 6",
      103: "numpad 7",
      104: "numpad 8",
      105: "numpad 9",
      106: "multiply",
      107: "add",
      109: "subtract",
      110: "decimal point",
      111: "divide",
      112: "f1",
      113: "f2",
      114: "f3",
      115: "f4",
      116: "f5",
      117: "f6",
      118: "f7",
      119: "f8",
      120: "f9",
      121: "f10",
      122: "f11",
      123: "f12",
      144: "num lock",
      145: "scroll lock",
      186: "semi-colon",
      187: "equal sign",
      188: "comma",
      189: "dash",
      190: "period",
      191: "forward slash",
      192: "grave accent",
      219: "open bracket",
      220: "back slash",
      221: "close braket",
      222: "single quote"
    };
    mouseKeyNamesByCode = {
      0: "left mouse button",
      1: "middle mouse button",
      2: "right mouse button"
    };
    keyCodesByName = {};
    for (keyCode in keyNamesByCode) {
      keyName = keyNamesByCode[keyCode];
      keyCodesByName[keyName] = parseInt(keyCode);
    }
    mouseKeyCodesByName = {};
    for (keyCode in mouseKeyNamesByCode) {
      keyName = mouseKeyNamesByCode[keyCode];
      mouseKeyCodesByName[keyName] = parseInt(keyCode);
    }
    ensureKeyNameIsValid = function(keyName) {
      if (!((keyCodesByName[keyName] != null) || (mouseKeyCodesByName[keyName] != null))) {
        throw "\"" + keyName + "\" is not a valid key name.";
      }
    };
    keyNameArrayToKeyCodeSet = function(keyNameArray) {
      var keyCodeSet, keyName, _i, _len;
      keyCodeSet = {};
      for (_i = 0, _len = keyNameArray.length; _i < _len; _i++) {
        keyName = keyNameArray[_i];
        keyCode = keyCodesByName[keyName];
        keyCodeSet[keyCode] = true;
      }
      return keyCodeSet;
    };
    updatePointerPosition = function(pointerPosition, display, event) {
      var element, left, top;
      element = display.canvas;
      left = 0;
      top = 0;
      while (element != null) {
        left += element.offsetLeft;
        top += element.offsetTop;
        element = element.offsetParent;
      }
      pointerPosition[0] = event.clientX - left + window.pageXOffset;
      pointerPosition[1] = event.clientY - top + window.pageYOffset;
      pointerPosition[0] -= display.size[0] / 2;
      return pointerPosition[1] -= display.size[1] / 2;
    };
    return module = {
      keyNamesByCode: keyNamesByCode,
      mouseKeyNamesByCode: mouseKeyNamesByCode,
      keyCodesByName: keyCodesByName,
      mouseKeyCodesByName: mouseKeyCodesByName,
      preventDefaultFor: function(keyNames) {
        var keyCodeSet;
        keyCodeSet = keyNameArrayToKeyCodeSet(keyNames);
        return window.addEventListener("keydown", function(keyDownEvent) {
          if (keyCodeSet[keyDownEvent.keyCode]) {
            return keyDownEvent.preventDefault();
          }
        });
      },
      createCurrentInput: function(display) {
        var currentInput;
        currentInput = {
          pressedKeys: {},
          pointerPosition: [0, 0]
        };
        window.addEventListener("keydown", function(keyDownEvent) {
          keyName = keyNamesByCode[keyDownEvent.keyCode];
          return currentInput.pressedKeys[keyName] = true;
        });
        window.addEventListener("keyup", function(keyUpEvent) {
          keyName = keyNamesByCode[keyUpEvent.keyCode];
          return currentInput.pressedKeys[keyName] = false;
        });
        window.addEventListener("mousedown", function(event) {
          keyName = mouseKeyNamesByCode[event.button];
          return currentInput.pressedKeys[keyName] = true;
        });
        window.addEventListener("mouseup", function(event) {
          keyName = mouseKeyNamesByCode[event.button];
          return currentInput.pressedKeys[keyName] = false;
        });
        display.canvas.addEventListener("mousemove", function(mouseMoveEvent) {
          return updatePointerPosition(currentInput.pointerPosition, display, mouseMoveEvent);
        });
        return currentInput;
      },
      onKeys: function(keyNames, callback) {
        var keysOfInterest;
        keysOfInterest = keyNameArrayToKeyCodeSet(keyNames);
        return window.addEventListener("keydown", function(keyDownEvent) {
          if (keysOfInterest[keyDownEvent.keyCode]) {
            keyName = keyNamesByCode[keyDownEvent.keyCode];
            return callback(keyName, keyDownEvent);
          }
        });
      },
      isKeyDown: function(currentInput, keyName) {
        ensureKeyNameIsValid(keyName);
        return currentInput.pressedKeys[keyName] === true;
      }
    };
  });

  module("Vec2", [], function() {
    var module;
    return module = {
      copy: function(v) {
        return [v[0], v[1]];
      },
      overwrite: function(v1, v2) {
        v1[0] = v2[0];
        return v1[1] = v2[1];
      },
      scale: function(v, s) {
        v[0] *= s;
        return v[1] *= s;
      },
      add: function(v1, v2) {
        v1[0] += v2[0];
        return v1[1] += v2[1];
      },
      subtract: function(v1, v2) {
        v1[0] -= v2[0];
        return v1[1] -= v2[1];
      },
      dot: function(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
      },
      length: function(v) {
        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
      },
      squaredLength: function(v) {
        return v[0] * v[0] + v[1] * v[1];
      },
      normalize: function(v) {
        var length;
        length = module.length(v);
        v[0] /= length;
        return v[1] /= length;
      },
      orthogonal: function(v) {
        var x, y;
        x = v[0];
        y = v[1];
        v[0] = -y;
        return v[1] = x;
      },
      applyTransform: function(v, t) {
        var x, y;
        x = v[0], y = v[1];
        v[0] = x * t[0][0] + y * t[0][1] + 1 * t[0][2];
        return v[1] = x * t[1][0] + y * t[1][1] + 1 * t[1][2];
      }
    };
  });

  module("Camera", ["Mat3x3", "Vec2", "Transform2d"], function(Mat3x3, Vec2, Transform2d) {
    var module;
    return module = {
      createCamera: function() {
        var camera;
        return camera = {
          position: [0, 0],
          rotation: 0,
          zoomFactor: 1
        };
      },
      transformRenderables: function(camera, renderables) {
        var offset, r, renderable, s, t, transform, _i, _len, _results;
        offset = Vec2.copy(camera.position);
        Vec2.scale(offset, -1);
        transform = Transform2d.identityMatrix();
        t = Transform2d.translationMatrix(offset);
        r = Transform2d.rotationMatrix(camera.rotation);
        s = Transform2d.scalingMatrix(camera.zoomFactor);
        Mat3x3.multiply(transform, s);
        Mat3x3.multiply(transform, r);
        Mat3x3.multiply(transform, t);
        _results = [];
        for (_i = 0, _len = renderables.length; _i < _len; _i++) {
          renderable = renderables[_i];
          _results.push(Vec2.applyTransform(renderable.position, transform));
        }
        return _results;
      }
    };
  });

  module("Mat3x3", [], function() {
    var module;
    return module = {
      multiply: function(m1, m2) {
        var m00, m01, m02, m10, m11, m12, m20, m21, m22;
        m00 = m1[0][0];
        m01 = m1[0][1];
        m02 = m1[0][2];
        m10 = m1[1][0];
        m11 = m1[1][1];
        m12 = m1[1][2];
        m20 = m1[2][0];
        m21 = m1[2][1];
        m22 = m1[2][2];
        m1[0][0] = m00 * m2[0][0] + m01 * m2[1][0] + m02 * m2[2][0];
        m1[0][1] = m00 * m2[0][1] + m01 * m2[1][1] + m02 * m2[2][1];
        m1[0][2] = m00 * m2[0][2] + m01 * m2[1][2] + m02 * m2[2][2];
        m1[1][0] = m10 * m2[0][0] + m11 * m2[1][0] + m12 * m2[2][0];
        m1[1][1] = m10 * m2[0][1] + m11 * m2[1][1] + m12 * m2[2][1];
        m1[1][2] = m10 * m2[0][2] + m11 * m2[1][2] + m12 * m2[2][2];
        m1[2][0] = m20 * m2[0][0] + m21 * m2[1][0] + m22 * m2[2][0];
        m1[2][1] = m20 * m2[0][1] + m21 * m2[1][1] + m22 * m2[2][1];
        return m1[2][2] = m20 * m2[0][2] + m21 * m2[1][2] + m22 * m2[2][2];
      }
    };
  });

  module("ModifiedPhysics", ["Vec2"], function(Vec2) {
    var module;
    return module = {
      parameters: {
        collisionResponse: {
          k: 10000,
          b: 0
        }
      },
      createBody: function() {
        var body;
        return body = {
          position: [0, 0],
          velocity: [0, 0],
          acceleration: [0, 0],
          orientation: 0,
          angularVelocity: 0,
          forces: [],
          mass: 1,
          timeDilation: 1
        };
      },
      integrateOrientation: function(bodies, passedTimeInS) {
        var body, entityId, _results;
        _results = [];
        for (entityId in bodies) {
          body = bodies[entityId];
          _results.push(body.orientation += body.angularVelocity * passedTimeInS);
        }
        return _results;
      },
      update: function(bodies, passedTimeInS, integrate) {
        integrate(bodies, passedTimeInS);
        return module.integrateOrientation(bodies, passedTimeInS);
      }
    };
  });

  module("Satellites", ["ModifiedPhysics", "Vec2", "Orbits", "Gravitation"], function(Physics, Vec2, Orbits, Gravitation) {
    var killerCost, killerDamagePerS, killerRange, module, nextEntityId, timeDilationMinDistance;
    nextEntityId = 0;
    timeDilationMinDistance = 50;
    killerRange = 45;
    killerDamagePerS = 1;
    killerCost = 300;
    return module = {
      createKiller: function(args) {
        var body, entity;
        body = Physics.createBody();
        body.position = args.position;
        body.velocity = args.velocity;
        return entity = {
          id: "satellite" + (nextEntityId += 1),
          components: {
            "bodies": body,
            "satellites": {
              targets: []
            }
          }
        };
      },
      launchSatellite: function(orbit, game, createEntity) {
        var position, velocity, _ref;
        if (game.budget >= killerCost) {
          _ref = Orbits.stateVectorsAtPeriapsis(orbit, Gravitation.mu), position = _ref[0], velocity = _ref[1];
          createEntity("satellite", {
            position: position,
            velocity: velocity
          });
          return game.budget -= killerCost;
        }
      },
      modifyTimeDilation: function(satelliteId, offset, bodies, satellites) {
        var body;
        if (satellites[satelliteId] != null) {
          body = bodies[satelliteId];
          body.timeDilation += offset;
          body.timeDilation = Math.max(0.5, body.timeDilation);
          return body.timeDilation = Math.min(3.0, body.timeDilation);
        }
      },
      handleNearbyAliens: function(satellites, aliens, bodies) {
        var alien, alienBody, alienId, alienWithinReach, satellite, satelliteBody, satelliteId, satelliteToAlien, squaredDistance, timeDilationHasToReset, _results;
        _results = [];
        for (satelliteId in satellites) {
          satellite = satellites[satelliteId];
          satellite.targets.length = 0;
          _results.push((function() {
            var _results1;
            _results1 = [];
            for (alienId in aliens) {
              alien = aliens[alienId];
              satelliteBody = bodies[satelliteId];
              alienBody = bodies[alienId];
              satelliteToAlien = Vec2.copy(satelliteBody.position);
              Vec2.subtract(satelliteToAlien, alienBody.position);
              squaredDistance = Vec2.squaredLength(satelliteToAlien);
              timeDilationHasToReset = squaredDistance <= timeDilationMinDistance * timeDilationMinDistance;
              if (timeDilationHasToReset) {
                satelliteBody.timeDilation = 1.0;
              }
              alienWithinReach = squaredDistance <= killerRange * killerRange;
              if (alienWithinReach) {
                _results1.push(satellite.targets.push(alienId));
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        }
        return _results;
      },
      handleTargets: function(satellites, aliens, passedTimeInS) {
        var alien, satellite, satelliteId, targetId, _results;
        _results = [];
        for (satelliteId in satellites) {
          satellite = satellites[satelliteId];
          _results.push((function() {
            var _i, _len, _ref, _results1;
            _ref = satellite.targets;
            _results1 = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              targetId = _ref[_i];
              alien = aliens[targetId];
              _results1.push(alien.health -= killerDamagePerS * passedTimeInS / satellite.targets.length);
            }
            return _results1;
          })());
        }
        return _results;
      }
    };
  });

  module("Gravitation", ["Vec2"], function(Vec2) {
    var G, module, mu;
    G = 5e4;
    mu = G;
    return module = {
      G: G,
      mu: mu,
      applyGravitation: function(bodies, G) {
        var body, entityId, force, forceMagnitude, squaredDistance, _results;
        if (G == null) {
          G = module.G;
        }
        _results = [];
        for (entityId in bodies) {
          body = bodies[entityId];
          squaredDistance = Vec2.squaredLength(body.position);
          forceMagnitude = G * body.mass / squaredDistance;
          force = Vec2.copy(body.position);
          Vec2.scale(force, -1);
          Vec2.normalize(force);
          Vec2.scale(force, forceMagnitude);
          _results.push(body.forces.push(force));
        }
        return _results;
      }
    };
  });

  module("Planets", ["Vec2"], function(Vec2) {
    var collidesWithPlanet, module, nextEntityId;
    nextEntityId = 0;
    collidesWithPlanet = function(body, planetRadius) {
      return Vec2.squaredLength(body.position) <= planetRadius * planetRadius;
    };
    return module = {
      planetRadius: 25,
      checkAlienCollisions: function(aliens, satellites, bodies, game, destroyEntity) {
        var alien, alienId, body, satellite, satelliteId, _results;
        for (alienId in aliens) {
          alien = aliens[alienId];
          body = bodies[alienId];
          if (collidesWithPlanet(body, module.planetRadius)) {
            destroyEntity(alienId);
            game.population -= alien.damage;
            game.population = Math.max(0, game.population);
            if (game.population === 0) {
              game.over = true;
              game.won = false;
            }
          }
        }
        _results = [];
        for (satelliteId in satellites) {
          satellite = satellites[satelliteId];
          body = bodies[satelliteId];
          if (collidesWithPlanet(body, module.planetRadius)) {
            _results.push(destroyEntity(satelliteId));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };
  });

  module("ModifiedInput", [], function() {
    var ensureKeyNameIsValid, keyCode, keyCodesByName, keyName, keyNameArrayToKeyCodeSet, keyNamesByCode, module, mouseKeyCodesByName, mouseKeyNamesByCode, updatePointerPosition;
    keyNamesByCode = {
      8: "backspace",
      9: "tab",
      13: "enter",
      16: "shift",
      17: "ctrl",
      18: "alt",
      19: "pause",
      20: "caps lock",
      27: "escape",
      32: "space",
      33: "page up",
      34: "page down",
      35: "end",
      36: "home",
      37: "left arrow",
      38: "up arrow",
      39: "right arrow",
      40: "down arrow",
      45: "insert",
      46: "delete",
      48: "0",
      49: "1",
      50: "2",
      51: "3",
      52: "4",
      53: "5",
      54: "6",
      55: "7",
      56: "8",
      57: "9",
      65: "a",
      66: "b",
      67: "c",
      68: "d",
      69: "e",
      70: "f",
      71: "g",
      72: "h",
      73: "i",
      74: "j",
      75: "k",
      76: "l",
      77: "m",
      78: "n",
      79: "o",
      80: "p",
      81: "q",
      82: "r",
      83: "s",
      84: "t",
      85: "u",
      86: "v",
      87: "w",
      88: "x",
      89: "y",
      90: "z",
      91: "left window key",
      92: "right window key",
      93: "select key",
      96: "numpad 0",
      97: "numpad 1",
      98: "numpad 2",
      99: "numpad 3",
      100: "numpad 4",
      101: "numpad 5",
      102: "numpad 6",
      103: "numpad 7",
      104: "numpad 8",
      105: "numpad 9",
      106: "multiply",
      107: "add",
      109: "subtract",
      110: "decimal point",
      111: "divide",
      112: "f1",
      113: "f2",
      114: "f3",
      115: "f4",
      116: "f5",
      117: "f6",
      118: "f7",
      119: "f8",
      120: "f9",
      121: "f10",
      122: "f11",
      123: "f12",
      144: "num lock",
      145: "scroll lock",
      186: "semi-colon",
      187: "equal sign",
      188: "comma",
      189: "dash",
      190: "period",
      191: "forward slash",
      192: "grave accent",
      219: "open bracket",
      220: "back slash",
      221: "close braket",
      222: "single quote"
    };
    mouseKeyNamesByCode = {
      0: "left mouse button",
      1: "middle mouse button",
      2: "right mouse button"
    };
    keyCodesByName = {};
    for (keyCode in keyNamesByCode) {
      keyName = keyNamesByCode[keyCode];
      keyCodesByName[keyName] = parseInt(keyCode);
    }
    mouseKeyCodesByName = {};
    for (keyCode in mouseKeyNamesByCode) {
      keyName = mouseKeyNamesByCode[keyCode];
      mouseKeyCodesByName[keyName] = parseInt(keyCode);
    }
    ensureKeyNameIsValid = function(keyName) {
      if (!((keyCodesByName[keyName] != null) || (mouseKeyCodesByName[keyName] != null))) {
        throw "\"" + keyName + "\" is not a valid key name.";
      }
    };
    keyNameArrayToKeyCodeSet = function(keyNameArray) {
      var keyCodeSet, keyName, _i, _len;
      keyCodeSet = {};
      for (_i = 0, _len = keyNameArray.length; _i < _len; _i++) {
        keyName = keyNameArray[_i];
        keyCode = keyCodesByName[keyName];
        keyCodeSet[keyCode] = true;
      }
      return keyCodeSet;
    };
    updatePointerPosition = function(pointerPosition, display, event) {
      var element, left, top;
      element = display.canvas;
      left = 0;
      top = 0;
      while (element != null) {
        left += element.offsetLeft;
        top += element.offsetTop;
        element = element.offsetParent;
      }
      pointerPosition[0] = event.clientX - left + window.pageXOffset;
      pointerPosition[1] = event.clientY - top + window.pageYOffset;
      pointerPosition[0] -= display.size[0] / 2;
      return pointerPosition[1] -= display.size[1] / 2;
    };
    return module = {
      keyNamesByCode: keyNamesByCode,
      mouseKeyNamesByCode: mouseKeyNamesByCode,
      keyCodesByName: keyCodesByName,
      mouseKeyCodesByName: mouseKeyCodesByName,
      preventDefaultFor: function(keyNames) {
        var keyCodeSet;
        keyCodeSet = keyNameArrayToKeyCodeSet(keyNames);
        return window.addEventListener("keydown", function(keyDownEvent) {
          if (keyCodeSet[keyDownEvent.keyCode]) {
            return keyDownEvent.preventDefault();
          }
        });
      },
      createCurrentInput: function(display) {
        var currentInput;
        currentInput = {
          pressedKeys: {},
          pointerPosition: [0, 0],
          wheel: {
            deltaX: 0,
            deltaY: 0
          }
        };
        window.addEventListener("keydown", function(keyDownEvent) {
          keyName = keyNamesByCode[keyDownEvent.keyCode];
          return currentInput.pressedKeys[keyName] = true;
        });
        window.addEventListener("keyup", function(keyUpEvent) {
          keyName = keyNamesByCode[keyUpEvent.keyCode];
          return currentInput.pressedKeys[keyName] = false;
        });
        window.addEventListener("mousedown", function(event) {
          keyName = mouseKeyNamesByCode[event.button];
          return currentInput.pressedKeys[keyName] = true;
        });
        window.addEventListener("mouseup", function(event) {
          keyName = mouseKeyNamesByCode[event.button];
          return currentInput.pressedKeys[keyName] = false;
        });
        display.canvas.addEventListener("mousemove", function(mouseMoveEvent) {
          return updatePointerPosition(currentInput.pointerPosition, display, mouseMoveEvent);
        });
        window.addEventListener("mousewheel", function(event) {
          currentInput.wheel.deltaX += event.wheelDeltaX;
          currentInput.wheel.deltaY += event.wheelDeltaY;
          return event.preventDefault();
        });
        return currentInput;
      },
      onKeys: function(keyNames, callback) {
        var keysOfInterest;
        keysOfInterest = keyNameArrayToKeyCodeSet(keyNames);
        return window.addEventListener("keydown", function(keyDownEvent) {
          if (keysOfInterest[keyDownEvent.keyCode]) {
            keyName = keyNamesByCode[keyDownEvent.keyCode];
            return callback(keyName, keyDownEvent);
          }
        });
      },
      isKeyDown: function(currentInput, keyName) {
        ensureKeyNameIsValid(keyName);
        return currentInput.pressedKeys[keyName] === true;
      }
    };
  });

  module("ModifiedEulerIntegrator", ["Vec2"], function(Vec2) {
    var module;
    return module = {
      integrate: function(bodies, passedTimeInS) {
        var body, effectiveTime, entityId, force, newAcceleration, positionChange, velocityChange, _i, _len, _ref, _results;
        _results = [];
        for (entityId in bodies) {
          body = bodies[entityId];
          newAcceleration = [0, 0];
          _ref = body.forces;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            force = _ref[_i];
            Vec2.scale(force, 1 / body.mass);
            Vec2.add(newAcceleration, force);
          }
          body.forces.length = 0;
          body.acceleration = newAcceleration;
          effectiveTime = passedTimeInS * body.timeDilation;
          velocityChange = Vec2.copy(body.acceleration);
          Vec2.scale(velocityChange, effectiveTime);
          Vec2.add(body.velocity, velocityChange);
          positionChange = Vec2.copy(body.velocity);
          Vec2.scale(positionChange, effectiveTime);
          _results.push(Vec2.add(body.position, positionChange));
        }
        return _results;
      }
    };
  });

  module("Orbits", ["Vec2"], function(Vec2) {
    var computeEccentricity, computeEccentricityVectorFromStateVectors, computeFocalDistance, computeFocalToCenter, computeSemiMajorAxis, computeSemiMinorAxis, computeVelocityAtPeriapsis, correctAuxiliaryEndpoint, determineApses, module;
    module = {
      orbitFromEndpoints: function(auxiliaryEndpoint, significantEndpoint, mu) {
        var apoapsis, apoapsisDistance, eccentricity, focalToCenter, orbit, periapsis, periapsisDistance, semiMajorAxis, semiMinorAxis, _ref;
        correctAuxiliaryEndpoint(auxiliaryEndpoint, significantEndpoint);
        _ref = determineApses(auxiliaryEndpoint, significantEndpoint), periapsis = _ref[0], apoapsis = _ref[1];
        periapsisDistance = Vec2.length(periapsis);
        apoapsisDistance = Vec2.length(apoapsis);
        eccentricity = computeEccentricity(periapsisDistance, apoapsisDistance);
        semiMajorAxis = computeSemiMajorAxis(periapsisDistance, eccentricity);
        semiMinorAxis = computeSemiMinorAxis(semiMajorAxis, eccentricity);
        focalToCenter = computeFocalToCenter(periapsis, eccentricity, semiMajorAxis, semiMinorAxis, mu);
        return orbit = {
          periapsis: periapsis,
          apoapsis: apoapsis,
          semiMajorAxis: semiMajorAxis,
          semiMinorAxis: semiMinorAxis,
          focalToCenter: focalToCenter
        };
      },
      stateVectorsAtPeriapsis: function(orbit, mu) {
        var apoapsisDistance, eccentricity, orbitIsCircular, periapsisDistance, position, velocity;
        orbitIsCircular = orbit.semiMajorAxis === orbit.semiMinorAxis;
        position = orbitIsCircular ? position = [orbit.semiMajorAxis, 0] : Vec2.copy(orbit.focalToCenter);
        Vec2.normalize(position);
        Vec2.scale(position, -orbit.semiMajorAxis);
        Vec2.add(position, orbit.focalToCenter);
        periapsisDistance = Vec2.length(position);
        apoapsisDistance = orbit.semiMajorAxis * 2 - Vec2.length(position);
        eccentricity = computeEccentricity(periapsisDistance, apoapsisDistance);
        velocity = computeVelocityAtPeriapsis(position, eccentricity, orbit.semiMajorAxis, mu);
        return [position, velocity];
      }
    };
    correctAuxiliaryEndpoint = function(auxiliaryEndpoint, significantEndpoint) {
      var auxiliaryDistance;
      auxiliaryDistance = Vec2.length(auxiliaryEndpoint);
      auxiliaryEndpoint[0] = significantEndpoint[0];
      auxiliaryEndpoint[1] = significantEndpoint[1];
      Vec2.normalize(auxiliaryEndpoint);
      return Vec2.scale(auxiliaryEndpoint, -auxiliaryDistance);
    };
    determineApses = function(auxiliaryEndpoint, significantEndpoint) {
      var apoapsis, auxiliaryEndpointIsPeriapsis, periapsis;
      auxiliaryEndpointIsPeriapsis = Vec2.squaredLength(auxiliaryEndpoint) <= Vec2.squaredLength(significantEndpoint);
      periapsis = null;
      apoapsis = null;
      if (auxiliaryEndpointIsPeriapsis) {
        periapsis = auxiliaryEndpoint;
        apoapsis = significantEndpoint;
      } else {
        periapsis = significantEndpoint;
        apoapsis = auxiliaryEndpoint;
      }
      return [periapsis, apoapsis];
    };
    computeEccentricity = function(periapsisDistance, apoapsisDistance) {
      var dAp, dPe;
      dPe = periapsisDistance;
      dAp = apoapsisDistance;
      return (dAp - dPe) / (dAp + dPe);
    };
    computeSemiMajorAxis = function(periapsisDistance, eccentricity) {
      return periapsisDistance / (1 - eccentricity);
    };
    computeSemiMinorAxis = function(semiMajorAxis, eccentricity) {
      return semiMajorAxis * Math.sqrt(1 - eccentricity * eccentricity);
    };
    computeFocalToCenter = function(periapsis, eccentricity, semiMajorAxis, semiMinorAxis, mu) {
      var eccentricityVector, focalDistance, focalToCenter, velocityAtPeriapsis;
      velocityAtPeriapsis = computeVelocityAtPeriapsis(periapsis, eccentricity, semiMajorAxis, mu);
      eccentricityVector = computeEccentricityVectorFromStateVectors(periapsis, velocityAtPeriapsis, mu);
      focalDistance = computeFocalDistance(semiMajorAxis, semiMinorAxis);
      focalToCenter = Vec2.copy(eccentricityVector);
      Vec2.normalize(focalToCenter);
      Vec2.scale(focalToCenter, -focalDistance);
      return focalToCenter;
    };
    computeVelocityAtPeriapsis = function(periapsis, eccentricity, semiMajorAxis, mu) {
      var speed, velocity;
      speed = Math.sqrt(((1 + eccentricity) * mu) / ((1 - eccentricity) * semiMajorAxis));
      velocity = Vec2.copy(periapsis);
      velocity = [-velocity[1], velocity[0]];
      Vec2.normalize(velocity);
      Vec2.scale(velocity, speed);
      return velocity;
    };
    computeEccentricityVectorFromStateVectors = function(position, velocity, mu) {
      var distance, eccentricityVector, speed, tmp;
      distance = Vec2.length(position);
      speed = Vec2.length(velocity);
      eccentricityVector = Vec2.copy(position);
      Vec2.scale(eccentricityVector, speed * speed / mu);
      tmp = Vec2.copy(velocity);
      Vec2.scale(tmp, Vec2.dot(position, velocity) / mu);
      Vec2.subtract(eccentricityVector, tmp);
      tmp = Vec2.copy(position);
      Vec2.scale(tmp, 1 / distance);
      Vec2.subtract(eccentricityVector, tmp);
      return eccentricityVector;
    };
    computeFocalDistance = function(semiMajorAxis, semiMinorAxis) {
      var a, b;
      a = semiMajorAxis;
      b = semiMinorAxis;
      return Math.sqrt(a * a - b * b);
    };
    return module;
  });

  module("Logic", ["ModifiedInput", "Entities", "Vec2", "Events", "ModifiedPhysics", "ModifiedEulerIntegrator", "Satellites", "Gravitation", "Orbits", "Aliens", "Planets", "Director"], function(Input, Entities, Vec2, Events, Physics, EulerIntegrator, Satellites, Gravitation, Orbits, Aliens, Planets, Director) {
    var createEntity, destroyEntity, entityFactories, module;
    entityFactories = {
      "satellite": Satellites.createKiller,
      "missile": Aliens.createMissile
    };
    createEntity = null;
    destroyEntity = null;
    return module = {
      createGameState: function() {
        var gameState;
        return gameState = {
          components: {},
          game: {
            over: false,
            won: null,
            population: 500,
            budget: 300
          }
        };
      },
      initGameState: function(gameState, guiSubscribers) {
        createEntity = function(type, args) {
          return Entities.createEntity(entityFactories, gameState.components, type, args);
        };
        destroyEntity = function(entityId) {
          return Entities.destroyEntity(gameState.components, entityId);
        };
        Events.subscribe(guiSubscribers, "select orbit", [Events.anyTopic], function(orbit) {
          return Satellites.launchSatellite(orbit, gameState.game, createEntity);
        });
        return Events.subscribe(guiSubscribers, "modify time dilation", [Events.anyTopic], function(event) {
          return Satellites.modifyTimeDilation(event.entityId, event.offset, gameState.components.bodies, gameState.components.satellites);
        });
      },
      updateGameState: function(gameState, currentInput, timeInS, passedTimeInS) {
        if (gameState.startTime == null) {
          gameState.startTime = timeInS;
        }
        Gravitation.applyGravitation(gameState.components.bodies);
        Physics.update(gameState.components.bodies, passedTimeInS, EulerIntegrator.integrate);
        Satellites.handleNearbyAliens(gameState.components.satellites, gameState.components.aliens, gameState.components.bodies);
        Satellites.handleTargets(gameState.components.satellites, gameState.components.aliens, passedTimeInS);
        Aliens.handleAlienDeaths(gameState.components.aliens, destroyEntity);
        Planets.checkAlienCollisions(gameState.components.aliens, gameState.components.satellites, gameState.components.bodies, gameState.game, destroyEntity);
        return Director.direct(timeInS - gameState.startTime, gameState.game, gameState.components.aliens, createEntity);
      }
    };
  });

  module("Game", ["Images", "Rendering", "ModifiedInput", "MainLoop", "Logic", "Graphics"], function(Images, Rendering, Input, MainLoop, Logic, Graphics) {
    return Images.loadImages(["images/star.png"], function(rawImages) {
      var currentInput, display, gameState, images, renderData, renderState;
      images = Images.process(rawImages);
      renderData = {
        "image": images
      };
      Input.preventDefaultFor(["up arrow", "down arrow", "left arrow", "right arrow", "space"]);
      display = Rendering.createDisplay();
      currentInput = Input.createCurrentInput(display);
      gameState = Logic.createGameState();
      renderState = Graphics.createRenderState();
      Logic.initGameState(gameState, renderState.guiSubscribers);
      Graphics.initRenderState(renderState);
      return MainLoop.execute(function(currentTimeInS, passedTimeInS) {
        Logic.updateGameState(gameState, currentInput, currentTimeInS, passedTimeInS);
        Graphics.updateRenderState(renderState, gameState, currentInput);
        return Rendering.render(Rendering.drawFunctions, display, renderData, renderState.renderables);
      });
    });
  });

  module("Graphics", ["Rendering", "Camera", "Vec2", "Events", "ModifiedInput", "Orbits", "Gravitation", "Planets"], function(Rendering, Camera, Vec2, Events, Input, Orbits, Gravitation, Planets) {
    var appendAliens, appendEndOfGameMessage, appendOrbitSelection, appendPlanet, appendSatelliteTargets, appendSatellites, appendStatus, handleOrbitSelection, handleTimeDilation, module, publishModifyTimeDilation, publishSelectOrbit, tooCloseToPlanet;
    publishSelectOrbit = null;
    publishModifyTimeDilation = null;
    module = {
      createRenderState: function() {
        var renderState;
        return renderState = {
          camera: Camera.createCamera(),
          renderables: [],
          guiSubscribers: Events.createSubscribers(),
          orbitSelection: {
            currentlySelecting: false,
            startingPoint: null,
            currentPoint: null
          }
        };
      },
      initRenderState: function(renderState) {
        publishSelectOrbit = function(orbit) {
          return Events.publish(renderState.guiSubscribers, "select orbit", null, orbit);
        };
        return publishModifyTimeDilation = function(entityId, factorOffset) {
          var event;
          event = {
            entityId: entityId,
            offset: factorOffset
          };
          return Events.publish(renderState.guiSubscribers, "modify time dilation", null, event);
        };
      },
      updateRenderState: function(renderState, gameState, currentInput) {
        renderState.renderables.length = 0;
        handleOrbitSelection(renderState.orbitSelection, currentInput);
        handleTimeDilation(gameState.components.bodies, currentInput);
        appendPlanet(renderState.renderables);
        appendOrbitSelection(renderState.orbitSelection, renderState.renderables);
        appendSatellites(gameState.components.bodies, gameState.components.satellites, renderState.renderables);
        appendAliens(gameState.components.bodies, gameState.components.aliens, renderState.renderables);
        appendSatelliteTargets(gameState.components.satellites, gameState.components.bodies, renderState.renderables);
        appendStatus(gameState.game, renderState.renderables);
        appendEndOfGameMessage(gameState.game, renderState.renderables);
        return Camera.transformRenderables(renderState.camera, renderState.renderables);
      }
    };
    handleOrbitSelection = function(orbitSelection, currentInput) {
      var orbit;
      if (Input.isKeyDown(currentInput, "left mouse button")) {
        if (orbitSelection.currentlySelecting) {
          return orbitSelection.currentPoint = Vec2.copy(currentInput.pointerPosition);
        } else {
          orbitSelection.currentlySelecting = true;
          orbitSelection.startingPoint = Vec2.copy(currentInput.pointerPosition);
          return orbitSelection.currentPoint = Vec2.copy(currentInput.pointerPosition);
        }
      } else {
        if (orbitSelection.currentlySelecting) {
          orbit = Orbits.orbitFromEndpoints(orbitSelection.startingPoint, orbitSelection.currentPoint, Gravitation.mu);
          if (!tooCloseToPlanet(orbit)) {
            publishSelectOrbit(orbit);
          }
          return orbitSelection.currentlySelecting = false;
        }
      }
    };
    handleTimeDilation = function(bodies, currentInput) {
      var body, delta, entityId, factor, mouseOverBody, mouseX, mouseY, selectionSize;
      factor = 0.01;
      selectionSize = 30;
      delta = currentInput.wheel.deltaY;
      if (delta !== 0) {
        for (entityId in bodies) {
          body = bodies[entityId];
          mouseX = currentInput.pointerPosition[0];
          mouseY = currentInput.pointerPosition[1];
          mouseOverBody = body.position[0] - selectionSize / 2 <= mouseX && body.position[0] + selectionSize / 2 >= mouseX && body.position[1] - selectionSize / 2 <= mouseY && body.position[1] + selectionSize / 2 >= mouseY;
          if (mouseOverBody) {
            publishModifyTimeDilation(entityId, delta * factor);
          }
        }
      }
      currentInput.wheel.deltaX = 0;
      return currentInput.wheel.deltaY = 0;
    };
    appendPlanet = function(renderables) {
      var renderable;
      renderable = Rendering.createRenderable("filledCircle");
      renderable.resource = {
        color: "rgb(0,0,255)",
        radius: 25
      };
      return renderables.push(renderable);
    };
    appendOrbitSelection = function(orbitSelection, renderables) {
      var color, orbit, renderable;
      if (orbitSelection.currentlySelecting) {
        orbit = Orbits.orbitFromEndpoints(orbitSelection.startingPoint, orbitSelection.currentPoint, Gravitation.mu);
        color = tooCloseToPlanet(orbit) ? "rgb(255,0,0)" : "rgb(255,255,255)";
        renderable = Rendering.createRenderable("ellipse");
        renderable.position = orbit.focalToCenter;
        renderable.orientation = Math.atan2(orbit.focalToCenter[1], orbit.focalToCenter[0]);
        renderable.resource = {
          color: color,
          semiMajorAxis: orbit.semiMajorAxis,
          semiMinorAxis: orbit.semiMinorAxis
        };
        return renderables.push(renderable);
      }
    };
    tooCloseToPlanet = function(orbit) {
      return Vec2.squaredLength(orbit.periapsis) <= Planets.planetRadius * Planets.planetRadius;
    };
    appendSatellites = function(bodies, satellites, renderables) {
      var body, entityId, halfSize, position, renderable, satellite, size, _results;
      size = [10, 10];
      halfSize = Vec2.copy(size);
      Vec2.scale(halfSize, 0.5);
      _results = [];
      for (entityId in satellites) {
        satellite = satellites[entityId];
        body = bodies[entityId];
        position = Vec2.copy(body.position);
        Vec2.subtract(position, halfSize);
        renderable = Rendering.createRenderable("rectangle");
        renderable.position = position;
        renderable.resource = {
          size: size
        };
        _results.push(renderables.push(renderable));
      }
      return _results;
    };
    appendAliens = function(bodies, aliens, renderables) {
      var alien, body, entityId, renderable, _results;
      _results = [];
      for (entityId in aliens) {
        alien = aliens[entityId];
        body = bodies[entityId];
        renderable = Rendering.createRenderable("filledCircle");
        renderable.position = body.position;
        renderable.resource = {
          color: "rgb(0,255,0)",
          radius: 5
        };
        _results.push(renderables.push(renderable));
      }
      return _results;
    };
    appendSatelliteTargets = function(satellites, bodies, renderables) {
      var laserStrength, renderable, satellite, satelliteBody, satelliteId, targetBody, targetId, _results;
      _results = [];
      for (satelliteId in satellites) {
        satellite = satellites[satelliteId];
        satelliteBody = bodies[satelliteId];
        laserStrength = 1 / satellite.targets.length;
        _results.push((function() {
          var _i, _len, _ref, _results1;
          _ref = satellite.targets;
          _results1 = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            targetId = _ref[_i];
            targetBody = bodies[targetId];
            if (targetBody != null) {
              renderable = Rendering.createRenderable("line");
              renderable.resource = {
                color: "rgba(255,255,255," + laserStrength + ")",
                start: satelliteBody.position,
                end: targetBody.position
              };
              _results1.push(renderables.push(renderable));
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        })());
      }
      return _results;
    };
    appendStatus = function(game, renderables) {
      var budget, budgetLabel, population, populationLabel;
      populationLabel = Rendering.createRenderable("text");
      populationLabel.position = [-300, -290];
      populationLabel.resource = {
        string: "Population:",
        textColor: "rgb(255,255,255)",
        centered: [false, false]
      };
      population = Rendering.createRenderable("text");
      population.position = [-240, -290];
      population.resource = {
        string: "" + game.population + " million",
        textColor: "rgb(255,255,255)",
        centered: [false, false]
      };
      budgetLabel = Rendering.createRenderable("text");
      budgetLabel.position = [-300, -270];
      budgetLabel.resource = {
        string: "Budget:",
        textColor: "rgb(255,255,255)",
        centered: [false, false]
      };
      budget = Rendering.createRenderable("text");
      budget.position = [-240, -270];
      budget.resource = {
        string: "$" + game.budget + "M",
        textColor: "rgb(255,255,255)",
        centered: [false, false]
      };
      renderables.push(populationLabel);
      renderables.push(population);
      renderables.push(budgetLabel);
      return renderables.push(budget);
    };
    appendEndOfGameMessage = function(game, renderables) {
      var message, renderable;
      if (game.over) {
        message = game.won ? "You win!" : "You lose";
        renderable = Rendering.createRenderable("text");
        renderable.resource = {
          string: message,
          font: "32px Arial Black",
          textColor: "rgb(255,255,255)",
          centered: [true, false]
        };
        return renderables.push(renderable);
      }
    };
    return module;
  });

  module("Aliens", ["ModifiedPhysics", "Vec2"], function(Physics, Vec2) {
    var initialHealth, module, nextEntityId;
    nextEntityId = 0;
    initialHealth = {
      "missile": 0.5
    };
    return module = {
      createMissile: function(args) {
        var angle, body, distance, entity, position, speed, velocity;
        angle = Math.random() * Math.PI * 2;
        distance = 500;
        speed = 10;
        position = [distance * Math.sin(angle), distance * Math.cos(angle)];
        velocity = Vec2.copy(position);
        Vec2.normalize(velocity);
        Vec2.scale(velocity, -speed);
        body = Physics.createBody();
        body.position = position;
        body.velocity = velocity;
        return entity = {
          id: "missile" + (nextEntityId += 1),
          components: {
            "bodies": body,
            "aliens": {
              health: initialHealth["missile"],
              damage: 50
            }
          }
        };
      },
      handleAlienDeaths: function(aliens, destroyEntity) {
        var alien, alienId, _results;
        _results = [];
        for (alienId in aliens) {
          alien = aliens[alienId];
          if (alien.health <= 0) {
            _results.push(destroyEntity(alienId));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };
  });

  module("Director", [], function() {
    var length, module, script;
    script = {
      nextEventIndex: 0,
      events: [
        {
          timeInS: 0.0,
          type: "spawn missile",
          data: {
            times: 1
          }
        }, {
          timeInS: 10.0,
          type: "spawn missile",
          data: {
            times: 2
          }
        }, {
          timeInS: 20.0,
          type: "spawn missile",
          data: {
            times: 4
          }
        }, {
          timeInS: 20.0,
          type: "funding",
          data: {
            amount: 300
          }
        }, {
          timeInS: 30.0,
          type: "spawn missile",
          data: {
            times: 6
          }
        }, {
          timeInS: 40.0,
          type: "funding",
          data: {
            amount: 300
          }
        }
      ]
    };
    length = function(map) {
      var key, numberOfElements, value;
      numberOfElements = 0;
      for (key in map) {
        value = map[key];
        numberOfElements += 1;
      }
      return numberOfElements;
    };
    return module = {
      direct: function(timeInS, game, aliens, createEntity) {
        var i, nextEvent, _i, _ref;
        nextEvent = script.events[script.nextEventIndex];
        if (nextEvent != null) {
          if (timeInS >= nextEvent.timeInS) {
            switch (nextEvent.type) {
              case "spawn missile":
                for (i = _i = 1, _ref = nextEvent.data.times; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
                  createEntity("missile");
                }
                break;
              case "funding":
                game.budget += nextEvent.data.amount;
            }
            return script.nextEventIndex += 1;
          }
        } else if (length(aliens) === 0) {
          game.over = true;
          return game.won = game.population > 0;
        }
      }
    };
  });

}).call(this);
